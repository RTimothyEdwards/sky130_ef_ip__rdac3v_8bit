#-----------------------------------------------------------------------
# Octave script for calculating offset error of a DAC
#-----------------------------------------------------------------------
# Octave script for use with efabless CACE
# Written by Tim Edwards, efabless, March 2019
# CACE generates a file with a data structure containing information
# from the SPICE runs in the following format:
#
# Name of file:  results.dat
# Name of structure: results
# Structure elements:
# (1) NAMES:  A list of names of the test conditions
# (2) UNITS:  A list of units of each of the test conditions
# (3) RESULT: The result of the SPICE run (1D or 2D)
# (3) CONDITIONx:  One list of values for each condition x for which the
#	      simulation was made.
#
# The purpose of the script is to manipulate RESULT to produce some
# alternate result, replace the RESULT values, and write output as
# file "results_out.dat".
#
# It is the responsibility of the Octave script to know what the
# incoming RESULT values mean, because the characterization setup will
# give UNITS for the result as the units of the final result (e.g., the
# output of this script).
#
# It can be assumed that this routine is passed only a single result
# value (output voltage) and the associated conditions.
#-----------------------------------------------------------------------
# Offset error calculation:
# x is the digital value b7:0 converted to an integer
# V(x) is the original value in RESULT:  The voltage output of the DAC
#	under the given set of conditions.
# FSR = (Vhigh - Vlow) 	(full-scale range)
# ALSB = (Vhigh - Vlow) / 256	(ideal voltage step size per LSB)
# Videal(x) = Vlow + x * ALSB
#
# offset(x) = 100 * ((V(x) - Videal(x)) / FSR)	 (in units of % FSR)
#-----------------------------------------------------------------------

# Load the results from CACE
args = argv();
load(args{1});

# Find the index of the conditions representing Vhigh, Vlow, and b7:0
vhighidx = -1;
vlowidx = -1;
bvecidx = -1;

names = results.("NAMES");
l = length(names);
for i = 1:l,
    n = names(i);
    if (strcmp(n, "Vhigh") == 1),
	vhighidx = i;
    elseif (strcmp(n, "Vlow") == 1),
	vlowidx = i;
    elseif (strcmp(n, "b[7:0]") == 1),
	bvecidx = i;
    endif
endfor

# Sanity checks
if (vhighidx < 0),
    printf("Error:  Cannot find condition Vhigh in list!");
    return
elseif (vlowidx < 0),
    printf("Error:  Cannot find condition Vlow in list!");
    return
elseif (bvecidx < 0),
    printf("Error:  Cannot find condition b[7:0] in list!");
    return
endif
    
result = results.("RESULT");

# Get the digital value array
cstr = sprintf("CONDITION%d", bvecidx);
bvals = results.(cstr);

# Convert digital binary string to integer
ival = bin2dec(bvals);

# Get Vhigh value
cstr = sprintf("CONDITION%d", vhighidx);
vhighval = results.(cstr)(1);

# Get Vlow value
cstr = sprintf("CONDITION%d", vlowidx);
vlowval = results.(cstr)(1);

# Compute FSR
fsr = vhighval - vlowval;

# Compute ALSB
alsb = fsr / 256.0;

# Compute ideal output value
videal = vlowval + ival * alsb;

# Compute offset
offset = result - (ival * alsb + vlowval);

# Compute offset as a fraction of fsr (CACE converts to %fsr)
offfrac = offset * fsr;

# Output the result value.  This should be the only text generated by the script.
printf("%g\n", offfrac)
