#-----------------------------------------------------------------------
# Octave script for calculating INL of a DAC
#-----------------------------------------------------------------------
# Octave script for use with efabless CACE
# Written by Tim Edwards, efabless, March 2019
# CACE generates a file with a data structure containing information
# from the SPICE runs in the following format:
#
# Name of file:  results.dat
# Name of structure: results
# Structure elements:
# (1) NAMES:  A list of names of the test conditions
# (2) UNITS:  A list of units of each of the test conditions
# (3) RESULT: The (single) result of the simulation.
# (4) CONDITIONx:  One list of values for each condition x for which the
#	      simulation was made.
#
# The purpose of the script is to manipulate RESULT to produce some
# alternate result, replace the RESULT values, and write output as
# file "results_out.dat".
#
# It is the responsibility of the Octave script to know what the
# incoming RESULT values mean, because the characterization setup will
# give UNITS for the result as the units of the final result (e.g., the
# output of this script).
#-----------------------------------------------------------------------
# INL calculation:
# x is the digital value b7:0 converted to an integer
# V(x) is the original value in RESULT:  The voltage output of the DAC
#	under the given set of conditions.
# ALSB = (Vhigh - Vlow) / 256	(ideal voltage step size per LSB)
#
# INL(x) = (RESULT - (x * ALSB + Vlow)) / ALSB	(in units of LSB)
#
# NOTE that this DAC is based on 256 steps with the highest step being
# 1 lsb below Vhigh.
#-----------------------------------------------------------------------

# Load the results from CACE (passed as an argument to the script)
args = argv();
load(args{1});

# Find the index of the conditions representing Vhigh, Vlow, and b7:0
# Warning:  Names are space-padded to the length of the longest name so
# that octave has a uniform character matrix.
vhighidx = -1;
vlowidx = -1;
bvecidx = -1;

names = results.("NAMES");
l = length(names);
for i = 1:l,
    n = names(i);
    if (strcmp(n, "Vhigh") == 1),
	vhighidx = i;
    elseif (strcmp(n, "Vlow") == 1),
	vlowidx = i;
    elseif (strcmp(n, "b[7:0]") == 1),
	bvecidx = i;
    endif
endfor

# Sanity checks
if (vhighidx < 0),
    printf("Error:  Cannot find condition Vhigh in list!");
    return
elseif (vlowidx < 0),
    printf("Error:  Cannot find condition Vlow in list!");
    return
elseif (bvecidx < 0),
    printf("Error:  Cannot find condition b[7:0] in list!");
    return
endif
    
# Get the digital value array
cstr = sprintf("CONDITION%d", bvecidx);
bvals = results.(cstr);

# Convert digital binary string to integer
ival = bin2dec(bvals);

# Get Vhigh values
cstr = sprintf("CONDITION%d", vhighidx);
vhighval = results.(cstr)(1);

# Get Vlow values
cstr = sprintf("CONDITION%d", vlowidx);
vlowval = results.(cstr)(1);

# Get RESULT values (voltage output)
vout = results.("RESULT");

# Compute ALSB
alsb = (vhighval - vlowval) / 256.0;

# Compute INL
inl = (vout - (ival * alsb + vlowval)) / alsb;

# Output the result vector.  This should be the only text generated by the script.
printf("%g\n", inl)
